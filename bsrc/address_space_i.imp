/*
 * Licensed to Systerel under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Systerel licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

IMPLEMENTATION
    address_space_i

REFINES
    address_space_r

SEES
    constants,
    service_write_decode_bs,
    service_mgr_1,
    service_response_cb_bs,
    write_value_pointer_bs

IMPORTS
    address_space_bs,
    response_write_bs,
    address_space_it,
    gen_subscription_event_bs,
    user_authorization_bs

PROMOTES
    readall_AddressSpace_Node,
    free_IndexRange,
    get_NodeClass,
    get_BrowseName,
    get_DisplayName,
    get_TypeDefinition,
    get_Reference_ReferenceType,
    get_Reference_TargetNode,
    get_Reference_IsForward,
    get_Node_RefIndexEnd,
    get_RefIndex_Reference,
    get_Value_StatusCode,
    read_AddressSpace_clear_value,
    read_AddressSpace_free_value,
    write_WriteResponse_msg_out,
    get_user_authorization

CONCRETE_VARIABLES
    ResponseWrite_allocated

INITIALISATION
    ResponseWrite_allocated := FALSE

LOCAL_OPERATIONS
    /* Outer treat operation. Validates isvalid, validates user, records the write. */
    serviceStatusCode, prev_value, prev_sc <-- treat_write_1(isvalid, status, p_user, nid, aid, value, index_range) =
    PRE
        isvalid : BOOL &
        status : t_StatusCode_i &
        p_user : t_user_i &
        p_user : t_user   &
        nid : t_NodeId_i &
        aid : t_AttributeId_i &
        value : t_Variant_i &
        (isvalid = TRUE
            =>
         status = e_sc_ok & /* TODO: this is redundant with isvalid = TRUE */
         nid : t_NodeId &
         aid : t_AttributeId &
         value : t_Variant) &
        (isvalid = FALSE
            =>
         status : {e_sc_bad_attribute_id_invalid, e_sc_bad_index_range_invalid}) &
        a_NodeId : t_Node >-> t_NodeId &
        a_Value : t_Node +-> t_Variant &
        index_range : t_IndexRange_i
    THEN
        serviceStatusCode,
        prev_sc,
        prev_value,
        a_Value
        :(
            serviceStatusCode : t_StatusCode_i &
            serviceStatusCode : t_StatusCode &
            prev_sc : t_StatusCode_i &
            prev_value : t_Variant_i &
            a_Value : t_Node +-> t_Variant &
            (isvalid = TRUE &
             nid : ran(a_NodeId) &
             aid = e_aid_Value &
             a_NodeClass(a_NodeId~(nid)) = e_ncl_Variable &
             e_operation_type_write |-> nid |-> aid |-> p_user : s_AuthorizedOperations &
             e_operation_type_read |-> nid |-> aid |-> p_user : s_AuthorizedOperations
             =>
             serviceStatusCode = e_sc_ok &
             prev_sc = a_Value_StatusCode(a_NodeId~(nid)) &
             prev_value = a_Value$0(a_NodeId~(nid)) &
             a_Value = a_Value$0 <+ {a_NodeId~(nid) |-> value}) &
            (not(isvalid = TRUE &
                 status : t_StatusCode_i &
                 status : t_StatusCode &
                 nid : ran(a_NodeId) &
                 aid = e_aid_Value &
                 a_NodeClass(a_NodeId~(nid)) = e_ncl_Variable) &
                 serviceStatusCode /= e_sc_bad_user_access_denied
             =>
             serviceStatusCode :
               {e_sc_bad_internal_error, e_sc_bad_attribute_id_invalid, e_sc_bad_node_id_unknown, e_sc_bad_write_not_supported, e_sc_bad_user_access_denied, e_sc_bad_index_range_no_data, e_sc_bad_index_range_invalid} &
             a_Value = a_Value$0)
        )
    END

OPERATIONS
    sc, ncl, val <-- read_NodeClass_Attribute(p_user, node, aid, index_range) =
    BEGIN
        ncl <-- get_NodeClass(node);
        sc, val <-- read_AddressSpace_Attribute_value(p_user, node, ncl, aid, index_range)
    END
    ;

    /* --------------------------------------------------------------------- */
    /* Service Write */

    bret <-- alloc_write_request_responses(nb_req) =
    BEGIN
        IF nb_req <= k_n_WriteResponse_max THEN
            ResponseWrite_allocated <-- alloc_write_request_responses_malloc(nb_req)
        ELSE
            ResponseWrite_allocated := FALSE
        END;
        bret := ResponseWrite_allocated
    END
    ;

    StatusCode_service <-- treat_write_request_WriteValues (p_user) =
    VAR
        l_nb_req,
        l_continue,
        l_aid,
        l_nid,
        l_value,
        l_index_range,
        l_wvi,
        l_status1,
        l_status2,
        l_prev_value_status,
        l_prev_value,
        l_isvalid,
        l_local_treatment,
        l_wv,
        l_bres_wv_copy,
        l_wv_copy
    IN
        StatusCode_service := e_sc_ok;
        l_nb_req <-- get_nb_WriteValue;
        l_continue <-- init_iter_write_request(l_nb_req);
        WHILE l_continue = TRUE DO
            l_continue, l_wvi <-- continue_iter_write_request;
            l_isvalid, l_status1, l_nid, l_aid, l_value, l_index_range <-- getall_WriteValue(l_wvi);
            /* Avoids the IFs with a local operation. */
            l_status2, l_prev_value, l_prev_value_status <-- treat_write_1(l_isvalid, l_status1, p_user, l_nid, l_aid, l_value, l_index_range);
            set_ResponseWrite_StatusCode(l_wvi, l_status2);
            l_wv <-- getall_WriteValuePointer(l_wvi);
            IF l_status2 = e_sc_ok
            THEN
                l_bres_wv_copy, l_wv_copy <-- copy_write_value_pointer_content (l_wv);
                IF l_bres_wv_copy = TRUE THEN
                    gen_data_changed_event (l_prev_value, l_prev_value_status, l_wv_copy)
                ELSE
                    gen_data_changed_event_failed (l_prev_value)
                END
            ELSE
                read_AddressSpace_free_value(l_prev_value)
            END;
            l_local_treatment <-- is_local_service_treatment;
            IF l_local_treatment = FALSE
            THEN
                l_bres_wv_copy, l_wv_copy <-- copy_write_value_pointer_content (l_wv);
                IF l_bres_wv_copy = TRUE THEN
                    srv_write_notification (l_wv_copy, l_status2)
                ELSE
                    /* TODO: Generates an out of memory service result or error trace ? */
                    skip
                END
            END;
            free_IndexRange (l_index_range)
        INVARIANT
            wreqs_to_iterate <: t_WriteValue &
            wreqs_iterated <: t_WriteValue &
            wreqs_to_iterate /\ wreqs_iterated = {} &
            wreqs_to_iterate \/ wreqs_iterated = cast_t_WriteValue[1..nb_WriteValue] &
            l_continue = bool(wreqs_to_iterate /= {}) &

            a_Value : t_Node +-> t_Variant &

            dom(a_Value) = dom(a_Value$0 <+
                               (a_NodeClass~[{e_ncl_Variable}]           <| a_NodeId ;
                                                                            WriteValue_NodeId~ ;
                                (wreqs_iterated /\
                                 WriteValue_AttributeId~[{e_aid_Value}]) <| WriteValue_Value)) &

            a_Value <: a_Value$0 <+
                       (a_NodeClass~[{e_ncl_Variable}]           <| a_NodeId ;
                                                                    WriteValue_NodeId~ ;
                        (cast_t_WriteValue[1..nb_WriteValue] /\
                         WriteValue_AttributeId~[{e_aid_Value}]) <| WriteValue_Value) &

            ResponseWrite_StatusCode = %wvi.(
                wvi : t_WriteValue &
                wvi : wreqs_iterated
                |
                {FALSE |-> e_sc_bad_attribute_id_invalid,
                 TRUE  |-> {FALSE |-> e_sc_bad_index_range_invalid,
                            TRUE |-> {FALSE |-> e_sc_bad_node_id_unknown,
                                      TRUE  |-> {FALSE |-> e_sc_bad_write_not_supported,
                                                 TRUE  |-> {FALSE |-> e_sc_bad_user_access_denied,
                                                            TRUE |-> {FALSE |-> e_sc_bad_index_range_invalid,
                                                                      TRUE |-> {FALSE |-> e_sc_bad_index_range_no_data,
                                                                                TRUE |-> e_sc_ok
                                                                               }(HasRange_VariantIndex(WriteValue_Value(wvi) |-> WriteValue_IndexRange(wvi)))
                                                                     }(IsValid_VariantIndex(WriteValue_Value(wvi) |-> WriteValue_IndexRange(wvi)))
                                                           }(bool(e_operation_type_write |-> WriteValue_NodeId(wvi) |-> WriteValue_AttributeId(wvi) |-> p_user : s_AuthorizedOperations))
                                                }(bool(WriteValue_AttributeId(wvi) = e_aid_Value &
                                                       a_NodeClass(a_NodeId~(WriteValue_NodeId(wvi))) = e_ncl_Variable))
                                     }(bool(WriteValue_NodeId(wvi) : ran(a_NodeId)))
                           }(bool(WriteValue_IndexRange(wvi) : t_IndexRange))
                }(bool(WriteValue_AttributeId(wvi) : {e_aid_NodeId, e_aid_NodeClass, e_aid_Value}))
            )
        VARIANT
            card(wreqs_to_iterate)
        END
    END
    ;

    dealloc_write_request_responses =
    BEGIN
        ResponseWrite_allocated := FALSE;
        reset_ResponseWrite
    END
    ;

    serviceStatusCode, prev_value, prev_sc <-- treat_write_1(isvalid, status, p_user, nid, aid, value, index_range) =
    VAR
        l_isvalid,
        l_node,
        l_ncl,
        l_authorized_write
    IN
        IF isvalid = TRUE THEN
            prev_sc := c_StatusCode_indet;
            prev_value := c_Variant_indet;
            serviceStatusCode := e_sc_bad_node_id_unknown;
            l_isvalid, l_node <-- readall_AddressSpace_Node(nid);
            IF l_isvalid = TRUE THEN
                IF aid = e_aid_Value THEN
                    l_ncl <-- get_NodeClass(l_node);
                    IF l_ncl = e_ncl_Variable THEN
                        /* Write authorization is for set_Value, and read authorization is for get_Value_StatusCode */
                        /* TODO: it should be decided what to do when the value is write only */
                        l_authorized_write <-- get_user_authorization(e_operation_type_write, nid, aid, p_user);
                        IF l_authorized_write = TRUE THEN
                            serviceStatusCode, prev_value, prev_sc <-- set_Value(p_user, l_node, value, index_range)
                        ELSE
                            serviceStatusCode := e_sc_bad_user_access_denied
                        END
                    /* TODO: ELSE clause */
                    END
                ELSE
                    serviceStatusCode := e_sc_bad_write_not_supported
                END
            /* TODO: ELSE clause */
            END
        ELSE
            serviceStatusCode := status;
            prev_sc := c_StatusCode_indet;
            prev_value := c_Variant_indet
        END
    END

END
